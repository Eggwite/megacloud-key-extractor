import * as t from '@babel/types';
import { getStringFromLiteral } from '../utils/extractionUtils.js';
import * as babel from '@babel/core';
import { validateKey } from '../validators/keyValidator.js';

/**
 * Extractor for keys constructed using `String.fromCharCode()`.
 *
 * This extractor is designed to handle patterns where a key is generated by
 * calling `String.fromCharCode()` with an array of character codes. It can
 * handle several variations of this pattern:
 *
 * 1.  **Direct Spread of an Array**:
 *     -   `String.fromCharCode(...[107, 101, 121])`
 *     -   Here, the array `[107, 101, 121]` is directly spread into `fromCharCode`.
 *
 * 2.  **Spread of a Mapped Array**:
 *     -   `String.fromCharCode(...[208, 204, 220].map(c => c - 101))`
 *     -   In this case, an array is first transformed using `.map()`, and the
 *         resulting array is then spread into `fromCharCode`. The extractor
 *         will evaluate the map function to resolve the final character codes.
 *
 * 3.  **Spread of an Array Identifier**:
 *     -   `const codes = [107, 101, 121];`
 *     -   `String.fromCharCode(...codes)`
 *     -   The extractor can resolve the array identifier `codes` to its
 *         statically defined value and then extract the key.
 *
 * The extractor works by identifying `CallExpression` nodes where the callee is
 * `String.fromCharCode`. It then analyzes the arguments to handle the different
 * patterns described above.
 *
 * @param {object} state - The state object for the extractor.
 * @param {Array<object>} state.keys - The array to which extracted keys will be added.
 */

// Helper to analyze the callback function of an Array.prototype.map() call
const analyzeMapCallback = (funcPath, t) => {
  if (!funcPath.isFunction()) {
    // Not a function, can't analyze
    return { usesParameter: true };
  }

  const param = funcPath.node.params[0];
  // If there's no parameter, it's definitely not using it.
  if (!param) {
    return { usesParameter: false };
  }

  // Check if the parameter is referenced in the function body.
  const binding = funcPath.scope.getBinding(param.name);
  return { usesParameter: binding.referenced };
};

const createFromCharCodeExtractor = (foundKeys, nonHexCandidates, wrongLengthCandidates, aliasMap = {}) => {
  const resolveAlias = name => {
    let currentName = name;
    const seen = new Set();
    while (aliasMap[currentName]) {
      if (seen.has(currentName)) break; // circular
      seen.add(currentName);
      currentName = aliasMap[currentName];
    }
    return currentName;
  };

  return {
    CallExpression(path) {
      if (path.parentPath.isReturnStatement()) {
        return; // Handled by the ReturnStatement visitor
      }
      const { callee, arguments: args } = path.node;

      let isFromCharCode = false;
      let calleeName = null;

      // Check if the callee is String.fromCharCode or an alias to it
      if (t.isMemberExpression(callee)) {
        const isFromCharCodeProperty =
          (t.isIdentifier(callee.property) && callee.property.name === 'fromCharCode') ||
          (t.isStringLiteral(callee.property) && callee.property.value === 'fromCharCode') ||
          // also match computed form: obj['fromCharCode']
          (callee.computed && t.isStringLiteral(callee.property) && callee.property.value === 'fromCharCode');

        if (isFromCharCodeProperty) {
          // Check if object is String or an alias
          if (t.isIdentifier(callee.object)) {
            const objName = callee.object.name;
            const resolvedName = resolveAlias(objName);
            if (resolvedName === 'String' || objName === 'String') {
              isFromCharCode = true;
              calleeName = 'String.fromCharCode';
            } else {
              // Could be another object with fromCharCode
              isFromCharCode = true;
              calleeName = `${objName}.fromCharCode`;
            }
          }
        }
      } else if (t.isIdentifier(callee) && callee.name === 'fromCharCode') {
        isFromCharCode = true;
        calleeName = 'fromCharCode';
      }

      if (!isFromCharCode) return;

      // Handle different fromCharCode call patterns

      // Case 1: fromCharCode with spread: String.fromCharCode(...array)
      if (args.length === 1 && t.isSpreadElement(args[0])) {
        const spreadArgument = args[0].argument;
        let charCodes = null;

        // Direct array spread: String.fromCharCode(...[1, 2, 3])
        if (t.isArrayExpression(spreadArgument)) {
          charCodes = spreadArgument.elements
            .map(element => {
              if (t.isNumericLiteral(element)) {
                return element.value;
              }
              // Try to handle string literals that can be parsed as numbers
              if (t.isStringLiteral(element)) {
                const num = parseInt(element.value, 10);
                if (!isNaN(num)) return num;
              }
              return null;
            })
            .filter(code => code !== null);
        }
        // Variable reference spread: String.fromCharCode(...E)
        else if (t.isIdentifier(spreadArgument)) {
          // try declarator init
          let arrNode = null;
          const binding = path.scope.getBinding(spreadArgument.name);
          if (binding && binding.path.isVariableDeclarator() && t.isArrayExpression(binding.path.node.init)) {
            arrNode = binding.path.node.init;
          } else if (binding) {
            // fallback: search upwards for an assignment to the variable
            path.findParent(p => {
              if (p.isBlockStatement() || p.isProgram()) {
                for (const stmtPath of p.get('body')) {
                  if (stmtPath.isExpressionStatement() && stmtPath.get('expression').isAssignmentExpression()) {
                    const assignment = stmtPath.get('expression').node;
                    if (
                      t.isIdentifier(assignment.left, { name: spreadArgument.name }) &&
                      t.isArrayExpression(assignment.right)
                    ) {
                      arrNode = assignment.right;
                      return true; // stop searching
                    }
                  }
                }
              }
              return false; // continue searching upwards
            });
          }
          if (arrNode) {
            charCodes = arrNode.elements
              .map(element => {
                if (t.isNumericLiteral(element)) return element.value;
                if (t.isStringLiteral(element)) {
                  const n = parseInt(element.value, 10);
                  if (!isNaN(n)) return n;
                }
                return null;
              })
              .filter(code => code !== null);
          }
        }

        // Process the extracted character codes
        if (charCodes && charCodes.length > 0) {
          try {
            const key = String.fromCharCode(...charCodes);
            const result = validateKey(key, calleeName, 'fromCharCode_spread');

            if (result.isValidKey) {
              if (!foundKeys.some(fk => fk.key === key && fk.type === 'fromCharCode_spread')) {
                foundKeys.push({ ...result });
              }
            } else if (result.isNonHex) {
              nonHexCandidates.push({ result: key, source: calleeName, type: 'fromCharCode_spread' });
            } else if (result.isWrongLength) {
              wrongLengthCandidates.push({
                result: key,
                source: calleeName,
                type: 'fromCharCode_spread',
                length: result.actualLength,
                expectedLength: result.expectedLength
              });
            }
          } catch (e) {
            // Handle any errors in processing
            console.error(`Error processing fromCharCode with array:`, e);
          }
        }
      }

      // Case 2: Direct arguments: String.fromCharCode(65, 66, 67)
      else if (
        args.length > 0 &&
        args.every(arg => t.isNumericLiteral(arg) || (t.isStringLiteral(arg) && !isNaN(parseInt(arg.value, 10))))
      ) {
        const charCodes = args
          .map(arg => {
            if (t.isNumericLiteral(arg)) return arg.value;
            if (t.isStringLiteral(arg)) return parseInt(arg.value, 10);
            return null;
          })
          .filter(code => code !== null);

        if (charCodes.length > 0) {
          try {
            const key = String.fromCharCode(...charCodes);
            const result = validateKey(key, calleeName, 'fromCharCode_direct');

            if (result.isValidKey) {
              if (!foundKeys.some(fk => fk.key === key && fk.type === 'fromCharCode_direct')) {
                foundKeys.push({ ...result });
              }
            } else if (result.isNonHex) {
              nonHexCandidates.push({ result: key, source: calleeName, type: 'fromCharCode_direct' });
            } else if (result.isWrongLength) {
              wrongLengthCandidates.push({
                result: key,
                source: calleeName,
                type: 'fromCharCode_direct',
                length: result.actualLength,
                expectedLength: result.expectedLength
              });
            }
          } catch (e) {
            // Handle any errors in processing
            console.error(`Error processing fromCharCode with direct args:`, e);
          }
        }
      }
    },

    // Add a visitor for ReturnStatement to catch arrow function returns with fromCharCode
    ReturnStatement(path) {
      const arg = path.node.argument;
      if (t.isCallExpression(arg)) {
        const { callee, arguments: args } = arg;

        let isFromCharCode = false;
        let calleeName = 'return_fromCharCode';

        if (t.isMemberExpression(callee)) {
          const isFromCharCodeProperty =
            (t.isIdentifier(callee.property) && callee.property.name === 'fromCharCode') ||
            (t.isStringLiteral(callee.property) && callee.property.value === 'fromCharCode') ||
            // also match computed form in returns
            (callee.computed && t.isStringLiteral(callee.property) && callee.property.value === 'fromCharCode');

          if (isFromCharCodeProperty) {
            if (t.isIdentifier(callee.object)) {
              const objName = callee.object.name;
              const resolvedName = resolveAlias(objName);
              if (resolvedName === 'String' || objName === 'String') {
                isFromCharCode = true;
                calleeName = 'String.fromCharCode';
              } else {
                // Could be another object with fromCharCode, let's be optimistic
                isFromCharCode = true;
                calleeName = `${objName}.fromCharCode`;
              }
            }
          }
        }

        if (!isFromCharCode) return;

        // Handle spread argument in return statement
        if (args.length === 1 && t.isSpreadElement(args[0])) {
          const spreadArgument = args[0].argument;
          let charCodes = null;
          if (t.isIdentifier(spreadArgument)) {
            // try declarator init
            let arrNode = null;
            const binding = path.scope.getBinding(spreadArgument.name);
            if (binding && binding.path.isVariableDeclarator() && t.isArrayExpression(binding.path.node.init)) {
              arrNode = binding.path.node.init;
            } else if (binding) {
              // fallback: search upwards for an assignment to the variable
              path.findParent(p => {
                if (p.isBlockStatement() || p.isProgram()) {
                  for (const stmtPath of p.get('body')) {
                    if (stmtPath.isExpressionStatement() && stmtPath.get('expression').isAssignmentExpression()) {
                      const assignment = stmtPath.get('expression').node;
                      if (
                        t.isIdentifier(assignment.left, { name: spreadArgument.name }) &&
                        t.isArrayExpression(assignment.right)
                      ) {
                        arrNode = assignment.right;
                        return true; // stop searching
                      }
                    }
                  }
                }
                return false; // continue searching upwards
              });
            }
            if (arrNode) {
              charCodes = arrNode.elements
                .map(element => {
                  if (t.isNumericLiteral(element)) {
                    return element.value;
                  }
                  if (t.isStringLiteral(element)) {
                    const num = parseInt(element.value, 10);
                    if (!isNaN(num)) return num;
                  }
                  return null;
                })
                .filter(code => code !== null);
            }
          }

          if (charCodes && charCodes.length > 0) {
            try {
              const key = String.fromCharCode(...charCodes);
              const result = validateKey(key, calleeName, 'fromCharCode_return');

              if (result.isValidKey) {
                if (!foundKeys.some(fk => fk.key === key && fk.type === 'fromCharCode_return')) {
                  foundKeys.push({ ...result });
                }
              } else if (result.isNonHex) {
                nonHexCandidates.push({ result: key, source: calleeName, type: 'fromCharCode_return' });
              } else if (result.isWrongLength) {
                wrongLengthCandidates.push({
                  result: key,
                  source: calleeName,
                  type: 'fromCharCode_return',
                  length: result.actualLength,
                  expectedLength: result.expectedLength
                });
              }
            } catch (e) {
              console.error(`Error processing fromCharCode in return:`, e);
            }
          }
        }
      }
    }
  };
};

export default createFromCharCodeExtractor;
