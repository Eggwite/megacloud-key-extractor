import * as t from '@babel/types';
import { validateKey } from '../validators/keyValidator.js';

// Helper to find a string literal value for a variable.
// Handles `var V = "..."` and `var V; V = "..."`.
function findStringDeclarationValue(path, varName, t) {
  const binding = path.scope.getBinding(varName);
  if (!binding) {
    return null;
  }

  let lastAssignedValue = null;
  let lastAssignmentPath = null;

  // Check the initial declaration
  if (binding.path.isVariableDeclarator() && t.isStringLiteral(binding.path.node.init)) {
    lastAssignedValue = binding.path.node.init.value;
    lastAssignmentPath = binding.path;
  }

  // Check all constant violations (assignments)
  for (const assignmentPath of binding.constantViolations) {
    // We only care about assignments that happen before the current path
    if (assignmentPath.node.start < path.node.start) {
      if (assignmentPath.isAssignmentExpression() && assignmentPath.get('right').isStringLiteral()) {
        // If this is the first assignment we've seen, or it's later than the last one
        if (!lastAssignmentPath || assignmentPath.node.start > lastAssignmentPath.node.start) {
          lastAssignedValue = assignmentPath.get('right').node.value;
          lastAssignmentPath = assignmentPath;
        }
      }
    }
  }

  return lastAssignedValue;
}

/**
 * Extractor for keys constructed using `string.slice()`.
 *
 * This extractor handles patterns where a key is generated by calling `.slice()` on a string.
 * It can handle:
 * 1.  **Direct slice on a String Literal**:
 *     -   `'---key'.slice(3)`
 *
 * 2.  **Slice on a variable holding a String Literal**:
 *     -   `const s = '---key'; s.slice(3)`
 *
 * The extractor works by identifying `CallExpression` nodes where the callee is
 * a member expression for `.slice()`. It then resolves the string and evaluates the slice.
 */
const createSliceExtractor = (foundKeys, nonHexCandidates, wrongLengthCandidates) => {
  return {
    CallExpression(path) {
      const { callee, arguments: args } = path.node;

      // Check for .slice() call: obj.slice() or obj['slice']()
      if (!t.isMemberExpression(callee)) return;

      const prop = callee.property;
      const isSliceCall =
        (t.isIdentifier(prop) && prop.name === 'slice') || (t.isStringLiteral(prop) && prop.value === 'slice');

      if (!isSliceCall) return;

      let originalString = null;
      let sourceName = 'slice_literal';

      // Case 1: "string".slice()
      if (t.isStringLiteral(callee.object)) {
        originalString = callee.object.value;
      }
      // Case 2: myVar.slice() where myVar = "string"
      else if (t.isIdentifier(callee.object)) {
        sourceName = callee.object.name;
        originalString = findStringDeclarationValue(path, sourceName, t);
      }

      if (originalString === null) return;

      // Evaluate slice arguments. We'll handle numeric literals.
      if (args.length > 0 && args.every(arg => t.isNumericLiteral(arg))) {
        const sliceArgs = args.map(arg => arg.value);
        try {
          const slicedString = String.prototype.slice.apply(originalString, sliceArgs);

          const result = validateKey(slicedString, sourceName, 'slice');

          if (result.isValidKey) {
            if (!foundKeys.some(fk => fk.key === slicedString && fk.type === 'slice')) {
              foundKeys.push({ ...result });
            }
          } else if (result.isNonHex) {
            nonHexCandidates.push({ result: slicedString, source: sourceName, type: 'slice' });
          } else if (result.isWrongLength) {
            wrongLengthCandidates.push({
              result: slicedString,
              source: sourceName,
              type: 'slice',
              length: result.actualLength,
              expectedLength: result.expectedLength
            });
          }
        } catch (e) {
          // debug.warn(`Failed to evaluate slice on "${originalString}" with args ${sliceArgs.join(', ')}`);
          return;
        }
      }
    }
  };
};

export default createSliceExtractor;
